import PubSub from 'pubsub-js';
import declare from 'dojo/_base/declare';
import i18n from './esi18n';

const _i18nAttributes = ['innerHTML', 'title', 'placeholder'];

const _localizeKey = (bundle, key) => bundle[key];

const _addToOrCreateArr = (obj, key, node) => {
  if (obj[key]) {
    obj[key].push(node);
  } else {
    obj[key] = [node];
  }
};

const NLSMixin = declare([], {
  /**
   * Array of localization bundles to load.
   * This holds unlocalized keys for all languages
   */
  nlsBundles: [],

  /**
   * Loaded localization bundles. E.g. if a bundle is called 'test' you can access it via:
   * this.NLSBundles.test
   */
  NLSBundles: {},
  NLSLocalized: {},

  /**
   * Array of attachpoints those specified in template will end up in this array. Initial values
   * (like the innerHTML) of these attachpoints will be treated as keys to be looked up in the
   * localization bundles.
   */
  nls: [],

  /**
   * If multiple keys are given as values in the template (as innerHTML)
   * for the i18n attachpoints the key used will depend on the current i18nState.
   * If only one key is provided that will be used independently of the state.
   * Note, do not set manually, use 'setI18nState' method instead.
   */
  _i18nKeys: [],
  _i18nKeyMap: {},

  constructor: function() {
    this.nls = [];
    this.NLSBundles = {};
  },

  setI18nState(state) {
    this._i18nState = state;
    this._localeChange();
  },

  localeChange() {
  },


  /**
   * Gets the bundle value at a specific index
   * @scazan: OK, this is nuts... but the old NLSBundle0 used to be used as both a localized object as well as a bundle of sorts.
   *  The bundles are now localized by esi18n exclusively so we keep the raw bundles in this.nlsBundles and a localized version
   *  in this.NLSBundle# (ie this.NLSBundle0, this.NLSBundle1). We also need to refer to bundles by name in other places.
   *  So this.nlsBundles[0] would look like { escoSomething: {root: ..., de: ..., sv: ...} }
   *  So to get the raw bundle in a specific position, we pull out the raw bundle object (this.nlsBundles[0]),
   *  then extract the first keyVal (Object.entries(this.nlsBundles[0])[0]) and get the Val (Object.entries(this.nlsBundles[0])[0][1])
   *
   * @returns {object} the localized bundle at the position specified from this.nlsBundles
   */
  getNLSBundleAt(index) {
    return Object.entries(this.nlsBundles[index])[0][1];
  },

  /**
   * Call this method from postCreate.
   */
  initNLS() {
    // Normalize and create inverse map to simplify parameter check
    const properties = {};

    // Checking (without creating a dependency) if subclass of dojo/Stateful.
    if (this.watch && this.get && this.set) {
      // If so, listen for changes to variables that can trigger a locale change,
      this.watch((name) => {
        if (properties.hasOwnProperty(name)) {
          // Lazy implementation, localizing all keys rather than those specifically concerned.
          this._localeChange();
        }
      });
    }
    // Connect to application events
    this._localeChangeSubcription = PubSub.subscribe('esi18n.localeChange', this._localeChange.bind(this));

    this._i18nKeys = [{}, {}, {}, {}, {}]; // Maximum four states.

    const addKeyMap = (passedKeys, node, attr) => {
      let key;
      const keys = passedKeys.split(/\s*,\s*/);
      if (keys.length === 1) {
        key = keys[0].trim();
        _addToOrCreateArr(this._i18nKeys[0], key, node);
        this._i18nKeyMap[key] = attr;
      }
    };

    this.nls.forEach((node) => {
      // if (node instanceof _WidgetBase) {
      if (node.set && node.get && node.watch) {
        addKeyMap(node.get('label'), node, dijit);
      } else {
        _i18nAttributes.forEach((attr) => {
          if (attr !== 'innerHTML' || (node.childNodes.length === 1
            && node.childNodes[0].nodeType === 3)) {
            let keys = '';
            if (attr === 'innerHTML') {
              keys = node.innerHTML.trim();
            }
            else {
              keys = node.getAttribute(attr) || '';
            }
            addKeyMap(keys, node, attr);
          }
        });
      }
    });

    this._localeChange();
  },

  destroy() {
    if (this._localeChangeSubcription) {
      PubSub.unsubscribe(this._localeChangeSubcription);
      delete this._localeChangeSubcription;
    }
    if (this.inherited) {
      this.inherited('destroy', arguments);
    }
  },


  _localizeKeys(bundle, keys2nodes) {
    const showKey = i18n.getLocale() === 'nls';

    for (const key in keys2nodes) {
      if (bundle[key] && keys2nodes.hasOwnProperty(key)) {
        keys2nodes[key].forEach(function (node) {
          // if (node instanceof _WidgetBase) {
          if (node.set && node.get && node.watch) {
            node.set('label', showKey ? key : _localizeKey(bundle, key));
          } else {
            if (this._i18nKeyMap[key] === 'innerHTML') {
              node.innerHTML = showKey ? key : _localizeKey(bundle, key);
            } else {
              node.setAttribute(
                this._i18nKeyMap[key],
                showKey ? key : _localizeKey(bundle, key),
              );
            }
          }
        }, this);
      }
    }
  },

  _localeChange() {
    this.nlsBundles.forEach((bundleKeyVal, index) => {
      Object.entries(bundleKeyVal)
        .forEach((keyVal) => {
          const [key, bundleObject] = keyVal;
          const bundle = i18n.getLocalization(bundleObject);
          // This creates the localizedBundle
          this[`NLSBundle${index}`] = bundle;
          this[`NLSLocalized${index}`] = bundle;
          this.NLSBundles[key] = bundle;
          this.NLSLocalized[key] = bundle;
          this._localizeKeys(bundle, this._i18nKeys[0]);
        });
    }, this);
    this.localeChange.call(this, arguments);
  },
});

NLSMixin.Dijit = declare([NLSMixin], {
  postCreate() {
    this.inherited('postCreate', arguments);
    this.initNLS();
  },
});

export default NLSMixin;
