import moment from 'moment';
import PubSub from 'pubsub-js';
import { isArray, isObject, template } from 'lodash-es';
import pluralRules from './pluralRules';

/**
 * @param {(Object|string|number)} parameters
 *
 * @returns {Object}
 */
const normalizeParameters = (parameters) => {
  if (typeof parameters === 'string') {
    // Adding a separate _PARAM# to support lodash templates
    return { 1: parameters, _PARAM1: parameters };
  }

  if (parameters === parseInt(parameters, 10)) {
    // Adding a separate _PARAM# to support lodash templates
    return { 1: parameters, _PARAM1: parameters };
  }

  if (parameters.class) {
    parameters._class = parameters.class;
  }

  if (isArray(parameters)) {
    const obj = {};
    for (let i = 0; i < parameters.length; i++) {
      obj[`${i}`] = parameters[i];
    }
    return obj;
  }

  if (isObject(parameters)) {
    Object.entries(parameters).forEach((keyVal) => {
      if (parseInt(keyVal[0], 10)) {
        parameters[`_PARAM${keyVal[0]}`] = keyVal[1];
      }
    });

    return parameters;
  }

  throw 'Parameters must be either an integer, an array or an object.';
};

/**
 * @param {string} str
 *
 * @returns {array}
 */
const splitLocalizedValue = (str) => {
  if (str == null) {
    console.warn('Invalid NLS String:', str);
    return str;
  }

  const cstr = str.replace(/\$(\d)/g, '\${$1}');
  let arr = cstr.split(/({{|}})/g);
  arr = arr.filter(item => (item !== '{{' && item !== '}}'));

  return arr.map((item, idx) => {
    if (idx % 2 === 1) {
      try {
        const obj = {};
        const plarr = item.split('|');
        const conf = plarr[0].split(':');
        obj.type = conf[0];
        if (conf.length === 2) {
          obj.variable = conf[1].replace(/\${(.*)}/, '$1');
        } else {
          obj.variable = '1';
        }
        plarr.shift();
        obj.forms = plarr;
        return obj;
      } catch (e) {
        throw `Syntax error in localization string: ${str}`;
      }
    } else {
      return item;
    }
  });
};

const joinLocalizedValue = (arr, language, parameters) => {
  const rule = pluralRules.findRule(language);
  const larr = arr.map((item) => {
    if (isObject(item)) {
      const pluralNumber = parseInt(parameters[item.variable], 10);

      return item.forms[rule(pluralNumber)];
    }

    return item;
  });
  return larr.join('');
};

/**
 * @param {Object} bundleFromLoader
 *
 * @returns {Object}
 */
const constructNLSHeirarchy = (bundleFromLoader) => {
  const rootLang = bundleFromLoader.filter(bundle => bundle.lang === 'root')[0];
  const nonRootLangs = bundleFromLoader.filter(bundle => bundle.lang !== 'root');

  // Dealing with our default language
  nonRootLangs.push({ lang: 'en', nls: {} });
  nonRootLangs.push({ lang: 'en-US', nls: {} });

  if (rootLang == null) {
    return null;
  }

  const componentNLSBundle = nonRootLangs.reduce((accum, nlsObject) => {
    accum[nlsObject.lang] = Object.create(rootLang.nls);
    // Assign the language-specific values to that object
    Object.assign(accum[nlsObject.lang], nlsObject.nls);

    return accum;
  }, {});

  return componentNLSBundle;
};

/**
 * @param {Object} bundle
 * @param {string} key
 *
 * @returns {string}
 */
const getNLSTemplate = (bundle, key) => (bundle[key] ? bundle[key] : '');

/**
 *
 * @param {string} nlsTemplateString
 * @param {Object} attrs
 *
 * @returns {String}
 */
const renderNLSTemplate = (nlsTemplateString, attrs) => {
  if (!nlsTemplateString) {
    return nlsTemplateString;
  }

  const normalizedParameters = attrs == null ? {} : normalizeParameters(attrs);
  let nlsString = joinLocalizedValue(
    splitLocalizedValue(nlsTemplateString),
    moment.locale(),
    normalizedParameters,
  );

  try {
    // lodash doesn't support ${1} as a parameter name so replaceing with _PARAM#
    // but only supporting up to 20 variables noted by index
    for (let i = 20; i >= 0; i--) {
      nlsString = nlsString.replace('${'+i+'}', '${_PARAM'+i+'}');
    }
    // Clean any instances of "class" parameters since this is a JS keyword
    if (normalizedParameters.class != null) {
      nlsString = nlsString.split('${class}').join('${_class}');
    }
    if (normalizedParameters._SINGLEPARAM == null) {
      const singleParamNLSString = nlsString.split('${1}').join('${_SINGLEPARAM}');
      return template(singleParamNLSString)(normalizedParameters);
    }

    return template(nlsString)(normalizedParameters);
  } catch (e) {
    console.warn(`Could not replace all variables in string: ${nlsString}.`);

    return nlsString;
  }
};

const esi18n = {
  /**
   *
   * @returns {string}
   */
  getLocale: () => moment.locale(),
  setLocale(locale) {
    this.set(locale);
  },
  normalizeLocale(locale) {
    return locale ? locale.toLowerCase() : this.getCurrentLocale();
  },
  /**
   * @param {Object} bundleFromLoader
   *
   * @returns {Object}
   */
  // getLocalization: (moduleName, bundleName, locale, onLoad) => { // OLD signature
  getLocalization(bundleFromLoader) {
    return constructNLSHeirarchy(bundleFromLoader)[moment.locale()];
  },

  /**
   * @param {string} locale
   * @param {function} callback
   *
   * @returns {esi18n}
   */
  set(locale, onLocaleChange) {
    const oldlocale = this.getLocale();
    this.setCurrentDefaultLocale(locale);

    PubSub.publish('esi18n.localeChange', [locale, oldlocale]);

    onLocaleChange && onLocaleChange();

    return this;
  },
  /**
   * Gets a date string and accepts options for formatting the date
   *
   * @param {Date|String} The date to be formatted
   * @param {object} options for how to format the date
   *
   * @returns {String}
   */
  getDate(date, formatOptions) {
    // choice of long, short, medium or full (plus any custom additions). Defaults to ‘short’
    // { selector: 'date', formatLength: 'medium' }
    // { selector: 'time', formatLength: 'short' }
    // { selector: 'date', datePattern: shortDateFormat }
    // { selector: 'time', formatLength: 'medium' }
    // { formatLength: 'full' }
    const parsedDate = moment(date);

    let format = 'lll';
    if (formatOptions) {
      if (formatOptions.datePattern) {
        format = formatOptions.datePattern;
      }
      else if (formatOptions.formatLength === 'full') {
        format = 'LLLL';
      }
      else {
        switch (formatOptions.selector) {
          case 'date':
            if (formatOptions.formatLength === 'short') {
              format = 'l';
            }
            else {
              format = 'LL';
            }
            break;
          case 'time':
            if (formatOptions.formatLength === 'short') {
              format = 'LT';
            }
            else if (formatOptions.formatLength === 'medium') {
              format = 'lll';
            }
            break;
          default:
            break;
        }
      }
    }

    return parsedDate.format(format);
  },
  /**
   * @param {string} locale
   *
   * @returns {string}
   */
  setCurrentDefaultLocale: locale => moment.locale(locale.toLowerCase()),

  // TODO @scazan Add this in based on defaults.js in commons
  addOverride() {
  },

  renderNLSTemplate,
  /**
   * @param {Object} bundleFromLoader
   * @param {string} key
   * @param {Object} attrs
   *
   * @returns {undefined}
   */
  localize(bundleFromLoader, key, attrs) {
    const nlsString = renderNLSTemplate(
      getNLSTemplate(this.getLocalization(bundleFromLoader), key),
      attrs,
    );

    return nlsString;
  },
};

export default esi18n;
